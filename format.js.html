

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: format.js | Source: format.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/tui-doc.css">

    
        
            <link type="text/css" rel="stylesheet" href="custom.css">
        
    
</head>
<body>
<nav class="lnb" id="lnb">
    <div class="logo" style="">
        
            <img src="img/toast-ui.png" width="100%" height="100%">
        
    </div>
    <div class="title">
        <h1><a href="index.html" class="link">Source: format.js</a></h1>
        
    </div>
    <div class="search-container" id="search-container">
        <input type="text" placeholder="Search">
        <ul></ul>
    </div>
    
        <ol class="lnb-tab">
            <li id="api-tab">
                <a href="#"><h4>API</h4></a>
            </li>
            <li id="examples-tab">
                <a href="#"><h4>Examples</h4></a>
            </li>
        </ol>
    
    <div class="lnb-examples hidden"><h3>Examples</h3><ul><li><a href="tutorial-colorful-statusbar.html">A colorful statusbar</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="colorful-statusbar_sub"></div></li><li><a href="tutorial-formats.html">File formats</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="formats_sub"></div></li></ul></div><div class="lnb-api hidden"><h3>Modules</h3><ul><li><a href="module-hedit.html">hedit</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:hedit_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="module-hedit.html#.emitKeys">emitKeys</a></li></ul><div class="member-type">Events</div><ul class="inner"><li><a href="module-hedit.html#~event:load">load</a></li><li><a href="module-hedit.html#~event:modeSwitch">modeSwitch</a></li><li><a href="module-hedit.html#~event:quit">quit</a></li><li><a href="module-hedit.html#~event:viewSwitch">viewSwitch</a></li></ul><div class="member-type">Typedef</div><ul class="inner"><li><a href="module-hedit.html#~CommandCallback">CommandCallback</a></li><li><a href="module-hedit.html#~OptionCallback">OptionCallback</a></li></ul></div></li><li><a href="module-hedit_file.html">hedit/file</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:hedit/file_sub"><div class="member-type">Events</div><ul class="inner"><li><a href="module-hedit_file.html#~event:beforeWrite">beforeWrite</a></li><li><a href="module-hedit_file.html#~event:close">close</a></li><li><a href="module-hedit_file.html#~event:open">open</a></li><li><a href="module-hedit_file.html#~event:write">write</a></li></ul></div></li><li><a href="module-hedit_log.html">hedit/log</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:hedit/log_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="module-hedit_log.html#~debug">debug</a></li><li><a href="module-hedit_log.html#~error">error</a></li><li><a href="module-hedit_log.html#~fatal">fatal</a></li><li><a href="module-hedit_log.html#~info">info</a></li><li><a href="module-hedit_log.html#~warn">warn</a></li></ul></div></li><li><a href="module-hedit_statusbar.html">hedit/statusbar</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:hedit/statusbar_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="module-hedit_statusbar.html#.hideMessage">hideMessage</a></li><li><a href="module-hedit_statusbar.html#.showMessage">showMessage</a></li></ul></div></li></ul></div><div class="lnb-api hidden"><h3>Classes</h3><ul><li><a href="Format.html">Format</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Format_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Format.html#array">array</a></li><li><a href="Format.html#array">array</a></li><li><a href="Format.html#child">child</a></li><li><a href="Format.html#child">child</a></li><li><a href="Format.html#endgroup">endgroup</a></li><li><a href="Format.html#float32">float32</a></li><li><a href="Format.html#float32be">float32be</a></li><li><a href="Format.html#float32le">float32le</a></li><li><a href="Format.html#float64">float64</a></li><li><a href="Format.html#float64be">float64be</a></li><li><a href="Format.html#float64le">float64le</a></li><li><a href="Format.html#group">group</a></li><li><a href="Format.html#int8">int8</a></li><li><a href="Format.html#int16">int16</a></li><li><a href="Format.html#int16be">int16be</a></li><li><a href="Format.html#int16le">int16le</a></li><li><a href="Format.html#int32">int32</a></li><li><a href="Format.html#int32be">int32be</a></li><li><a href="Format.html#int32le">int32le</a></li><li><a href="Format.html#sequence">sequence</a></li><li><a href="Format.html#sequence">sequence</a></li><li><a href="Format.html#uint8">uint8</a></li><li><a href="Format.html#uint16">uint16</a></li><li><a href="Format.html#uint16be">uint16be</a></li><li><a href="Format.html#uint16le">uint16le</a></li><li><a href="Format.html#uint32">uint32</a></li><li><a href="Format.html#uint32be">uint32be</a></li><li><a href="Format.html#uint32le">uint32le</a></li></ul></div></li></ul></div>
</nav>
<div id="resizer"></div>

<div class="main" id="main">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Color names to integers map.
const COLORS = {
    white: 0,
    gray: 1,
    blue: 2,
    red: 3,
    pink: 4,
    green: 5,
    purple: 6,
    orange: 7
};

// Helper function to join two optional strings
function join(a, b) {
    if (a &amp;&amp; b) {
        return a + ' > ' + b;
    } else {
        return a ? a : b;
    }
}

/**
 * A `Format` represents the binary structure of a file.
 *
 * A format is logically divided in **spans**, each of which holds some information
 * like an user friendly name and its length. The name is displayed in the statusbar
 * at the bottom of the screen to help the user navigate the file.
 *
 * Some file formats have spans that depend on the actual value of some bytes before them
 * (think of a Pascal-style string), so it is needed to establish some kind of dependency
 * on those bytes. To accomplish this, you can assign a variable name to a span and read
 * its value later when needed. See below for an example of the Pascal string format.
 *
 * The `Format` class exposes a fluent API to build formats in a single expression,
 * and can be combined to create complex trees out of simple smaller formats.
 * When you nest formats (using [array()]{@link Format#array}, or [child()]{@link Format#child},
 * as well as when using [group()]{@link Format#group}), you can always specify a name:
 * this name will be prepended to the name of the inner spans, resulting in names with the following structure:
 * ```
 * 'Group 1 > Group 2 > A byte'
 * ```
 *
 * You can access this class importing `hedit/format`:
 * ```
 * import Format from 'hedit/format';
 * ```
 * 
 * @example
 * // This is a format describing a sequence of two integers of diffent lengths
 * const exampleFormat =
 *     new Format()
 *         .uint16('A 16 bit integer', 'orange')
 *         .uint32('A longer 32 bit integer', 'blue');
 *
 * @example
 * // This is a format for a Pascal-like string, i.e. a string with its length prefixed.
 * const pascalString =
 *     new Format()
 *         .uint8('String length', 'orange', 'len')
 *         .array('String contents', 'len', 'blue');
 *         // The line above is a shortcut for:
 *         // .array('String contents', vars => vars.len, 'blue');
 *
 * @see For a list of the builtin formats, check [the source](https://github.com/95ulisse/hedit/tree/master/src/js/format).
 */
class Format {

    constructor() {
        this._segments = [];
    }

    /**
     * Repeates a child format a fixed number of times.
     *
     * @param {string?} name - Name of this segment.
     * @param {integer|function|string} length - How many times to repeat the child format.
     *                                  If it is an integer, it represents a fixed number of repetitions.
     *                                  If it is a function, it is called with a dictionary of all the available variables
     *                                  and is expected to return an integer. If it is a string, it is treated as a
     *                                  shortcut for `vars => vars[length]`.
     * @param {Format} child - Child format to repeat.
     *
     *//**
     *
     * Adds a span of raw bytes to the format.
     *
     * @param {string?} name - Name of this segment.
     * @param {integer|function|string} length - How many times to repeat the child format.
     *                                  If it is an integer, it represents a fixed number of repetitions.
     *                                  If it is a function, it is called with a dictionary of all the available variables
     *                                  and is expected to return an integer. If it is a string, it is treated as a
     *                                  shortcut for `vars => vars[length]`.
     * @param {string} [color=white] - Color of the span.
     */
    array(name, length, child = 'white') {
        const repeat = typeof length === 'string' ? data => 0 + data[length] : length;

        if (child instanceof Format) {

            // A composite child
            this._segments.push({
                child: {
                    *__linearize(proxy, absoffset, basename, variables) {
                        const n = typeof repeat === 'function' ? repeat(variables) : repeat;
                        let offset = absoffset;
                        for (let i = 0; i &lt; n; i++) {
                            for (let childseg of child.__linearize(proxy, offset, join(basename, name), Object.create(variables))) {
                                yield childseg;
                                offset = childseg.to + 1;
                            }
                        }
                    }
                }
            });

        } else if (typeof child === 'string') {

            // Shortcut for a simple array of bytes
            this._segments.push({
                child: {
                    *__linearize(proxy, absoffset, basename, variables) {
                        const n = typeof repeat === 'function' ? repeat(variables) : repeat;
                        if (n > 0) {
                            yield {
                                name: join(basename, name),
                                color: COLORS[child],
                                from: absoffset,
                                to: absoffset + n - 1
                            };
                        }
                    }
                }
            });

        }

        return this;
    }

    /**
     * Adds a child format to this format.
     * This is equivalent to `array(name, 1, c)`.
     *
     * @param {string} name - Name of this span.
     * @param {Format} c - Child format to insert.
     *
     *//**
     *
     * Adds a child format to this format.
     * This is equivalent to `array(null, 1, c)`.
     *
     * @param {Format} c - Child format to insert.
     */
    child(name, c) {
        if (typeof c === 'undefined') {
            c = name;
            name = null;
        }
        return this.array(name, 1, c);
    }

    /**
     * Adds an infinite sequence of the given child format to this format.
     * This is equivalent to `array(name, Infinity, c)`.
     *
     * @param {string} name - Name of this span.
     * @param {Format} c - Child format to repeat indefinitely.
     *
     *//**
     *
     * Adds an infinite sequence of the given child format to this format.
     * This is equivalent to `array(null, Infinity, c)`.
     *
     * @param {Format} c - Child format to repeat indefinitely.
     */
    sequence(name, c) {
        if (typeof c === 'undefined') {
            c = name;
            name = null;
        }
        return this.array(name, Infinity, c);
    }

    /**
     * Groups multiple spans under a single name.
     * There **must** be a matching call to [endgroup()]{@link Format#endgroup}.
     *
     * @param {string} name - Group name.
     * @example
     * // This generates the following two spans with the following names:
     * // Group > A byte
     * // Group > Another byte
     * new Format()
     *     .group('Group')
     *         .uint8('A byte')
     *         .uint8('Another byte')
     *     .endgroup();
     */
    group(name) {
        const childFormat = new Format();
        childFormat._parent = this;
        this.child(name, childFormat);
        return childFormat;
    }

    /**
     * Ends a group started with [group()]{@link Format#group}.
     * There **must** be a matching call to [group()]{@link Format#group}.
     *
     * @example
     * // This generates the following two spans with the following names:
     * // Group > A byte
     * // Group > Another byte
     * new Format()
     *     .group('Group')
     *         .uint8('A byte')
     *         .uint8('Another byte')
     *     .endgroup();
     */
    endgroup() {
        const parent = this._parent;
        if (!parent) {
            throw new Error('Unbalanced group()/endgroup() calls.');
        }
        delete this._parent;
        return parent;
    }

    *__linearize(proxy, absoffset, basename, variables) {

        if (this._parent) {
            throw new Error('Unbalanced group()/endgroup() calls.');
        }

        let offset = absoffset;

        // Iterate over all the segments computing the actual absolute offsets
        for (let seg of this._segments) {
            if (seg.child) {
                for (let childseg of seg.child.__linearize(proxy, offset, join(basename, seg.name), Object.create(variables))) {
                    yield childseg;
                    offset = childseg.to + 1;
                }
            } else if (seg.length > 0) {
                if (seg.id) {
                    variables[seg.id] = seg.read(proxy, offset);
                }
                yield {
                    name: join(basename, seg.name),
                    color: COLORS[seg.color],
                    from: offset,
                    to: offset + seg.length - 1
                };
                offset += seg.length;
            }
        }

    }

};


function addCommonMethod(name, length, m, endianess) {
    if (endianess) {
        
        // Generate two methods for the little and big endian version
        Format.prototype[name + 'le'] = function (name, color = 'white', id) {
            this._segments.push({
                name,
                color,
                length,
                id,
                read(proxy, off) {
                    return m.call(new DataView(proxy.read(off, length)), 0, true /* Little endian */);
                }
            });
            return this;
        };
        Format.prototype[name + 'be'] = function (name, color = 'white', id) {
            this._segments.push({
                name,
                color,
                length,
                id,
                read(proxy, off) {
                    return m.call(new DataView(proxy.read(off, length)), 0, false /* Big endian */);
                }
            });
            return this;
        };
 
        // Name without endianess specification defaults to big endian
        Format.prototype[name] = Format.prototype[name + 'be'];

    } else {

        // Generate a single method regardless of the endianess
        Format.prototype[name] = function (name, color = 'white', id) {
            this._segments.push({
                name,
                color,
                length,
                id,
                read(proxy, off) {
                    return m.call(new DataView(proxy.read(off, length)), 0);
                }
            });
            return this;
        };

    }

}

/**
 * Adds a span of 1 byte to the current format.
 * The difference between the signed and unsigned versions matters only if reading
 * the actual value of the byte.
 *
 * @name Format#int8
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
addCommonMethod('int8', 1, DataView.prototype.getInt8, false);

/**
 * Adds a span of 1 byte to the current format.
 * The difference between the signed and unsigned versions matters only if reading
 * the actual value of the byte.
 *
 * @name Format#uint8
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
addCommonMethod('uint8', 1, DataView.prototype.getUint8, false);

/**
 * Adds a span of 2 bytes to the current format.
 * The difference between the signed, unsigned, little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#int16
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
/**
 * Adds a span of 2 bytes to the current format.
 * The difference between the signed, unsigned, little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#int16le
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
/**
 * Adds a span of 2 bytes to the current format.
 * The difference between the signed, unsigned, little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#int16be
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
/**
 * Adds a span of 2 bytes to the current format.
 * The difference between the signed, unsigned, little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#uint16
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
/**
 * Adds a span of 2 bytes to the current format.
 * The difference between the signed, unsigned, little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#uint16le
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
/**
 * Adds a span of 2 bytes to the current format.
 * The difference between the signed, unsigned, little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#uint16be
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
addCommonMethod('int16', 2, DataView.prototype.getInt16, true );
addCommonMethod('uint16', 2, DataView.prototype.getUint16, true );

/**
 * Adds a span of 4 bytes to the current format.
 * The difference between the signed, unsigned, little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#int32
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
/**
 * Adds a span of 4 bytes to the current format.
 * The difference between the signed, unsigned, little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#int32le
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
/**
 * Adds a span of 4 bytes to the current format.
 * The difference between the signed, unsigned, little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#int32be
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
/**
 * Adds a span of 4 bytes to the current format.
 * The difference between the signed, unsigned, little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#uint32
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
/**
 * Adds a span of 4 bytes to the current format.
 * The difference between the signed, unsigned, little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#uint32le
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
/**
 * Adds a span of 4 bytes to the current format.
 * The difference between the signed, unsigned, little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#uint32be
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
addCommonMethod('int32', 4, DataView.prototype.getInt32, true );
addCommonMethod('uint32', 4, DataView.prototype.getUint32, true );

/**
 * Adds a span of 4 bytes to the current format.
 * The difference between the little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#float32
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
/**
 * Adds a span of 4 bytes to the current format.
 * The difference between the little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#float32le
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
/**
 * Adds a span of 4 bytes to the current format.
 * The difference between the little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#float32be
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
addCommonMethod('float32', 4, DataView.prototype.getFloat32, true );

/**
 * Adds a span of 8 bytes to the current format.
 * The difference between the little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#float64
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
/**
 * Adds a span of 8 bytes to the current format.
 * The difference between the little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#float64le
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
/**
 * Adds a span of 8 bytes to the current format.
 * The difference between the little and big endian
 * versions matters only if reading the actual value of the byte.
 * If no endianess is specified, the default is big endian.
 *
 * @name Format#float64be
 * @function
 * @param {string?} name - Name of the span.
 * @param {string} [color=white] - Color of the span.
 * @param {string} [id] - Name of the variable in which to store the actual value of this byte.
 */
addCommonMethod('float64', 8, DataView.prototype.getFloat64, true );


export { Format as default };
</code></pre>
        </article>
    </section>




</div>

<footer>
    <img class="logo" src="img/toast-ui.png" style="">
    <div class="footer-text">NHN Entertainment. Frontend Development Lab</div>
</footer>
<script>prettyPrint();</script>
<script src="scripts/jquery.min.js"></script>
<script src="scripts/tui-doc.js"></script>
<script src="scripts/linenumber.js"></script>

    <script>
        var id = '_sub'.replace(/"/g, '_');
        var selectedApi = document.getElementById(id); // do not use jquery selector
        var $selectedApi = $(selectedApi);

        $selectedApi.removeClass('hidden');
        $selectedApi.parent().find('.glyphicon').removeClass('glyphicon-plus').addClass('glyphicon-minus');
        showLnbApi();
    </script>

</body>
</html>
